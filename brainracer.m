function [S] = brainracer(varargin)
% BrainRacer by Stef

decay = 0.001;
increment = 0.5;
decision_boundary = 0.7;
C = ClassDecider(decay, increment);

f_clr = [.741 .717 .42];
S.fig = figure('units','pixels',...
               'name','Brainracer',...
               'menubar','none',...
               'numbertitle','off',...
               'position',[100 100 650 720],...
               'keypressfcn',@fig_kpfcn,...%
               'color',f_clr,...
               'busyaction','cancel',...
               'renderer','opengl');
center = 325;
car_width = 300;

S.axs = axes('units','pix',...
             'position',[325-(car_width/2) 0 car_width 100],...
             'ycolor',f_clr,...
             'xcolor',f_clr,...
             'color',f_clr,...
             'xtick',[],'ytick',[],...
             'xlim',[-.1 7.1],...
             'ylim',[-.1 7.1],...
             'visible','off');           

r_col = [(65/255) (79/255) (205/255)];
S.rct = rectangle('pos',[0 0 7 7],...
                  'curvature',.3,...
                  'facecolor',r_col,...
                  'edgecolor','r',...
                  'linewidth',2); % This is used below the preview.


left_road_center_start = center - 25;
left_road_center_stop = center - 225;
start_y = 400;
stop_y = 0;
start_size = 25;
stop_size = 200;

steering_rect_width = 300;
steering_rect_height = 75;
steering_rect_y_pos = 500;

[car_image, map, alpha_incoming] = imread('images/car_after_crop.png');
[our_car_image, map, alpha_our] = imread('images/cabrio.jpg');  
street_image=imread('images/street.png');
incoming_car_pos = getRandomSeries(10, 3, 0.5); %10= series of cars, 3 is max_series, 0.5 = p_left
our_car_pos = 1;
incoming_index = 0;
running = true;
max_i = 25;
while(running)
    tic
    incoming_index = incoming_index + 1;
    if incoming_index > size(incoming_car_pos)
        incoming_index = 1;
    end
    for i = 0:max_i
        clf(S.fig, 'reset');
        set(S.fig, 'keypressfcn',@fig_kpfcn);
        % This creates the 'background' axes
        ha = axes('units','normalized', ...
                'position',[0 0 1 1]);
        % Move the background axes to the bottom
        uistack(ha,'bottom');
        % Load in a background image and display it using the correct colors
        % The image used below, is in the Image Processing Toolbox.  If you do not have %access to this toolbox, you can use another image file instead.

        hi = imagesc(street_image);
        colormap gray
        % Turn the handlevisibility off so that we don't inadvertently plot into the axes again
        % Also, make the axes invisible
        set(ha,'handlevisibility','off', ...
                    'visible','off');
        
        current_x = left_road_center_start - (left_road_center_start - left_road_center_stop)/max_i*i;
        current_size = 25 + (i/max_i)*(stop_size-start_size);
        if incoming_car_pos(incoming_index) == 1
            current_x = mirror(current_x, current_size);
        end
        current_y = start_y/max_i*(max_i-i);
        S.car_pos = axes('units','pix',...
                 'position',[current_x current_y current_size current_size],...
                 'ycolor',[0 1 1],...
                 'xcolor',[1 1 1],...
                 'color',[1 1 1],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','off');

        incoming_car_handle = imshow(car_image);
        set(incoming_car_handle, 'AlphaData', alpha_incoming);
        
        current_size = stop_size;
        current_x = left_road_center_stop;
        if our_car_pos == 1
            current_x = mirror(current_x, current_size);
        end
        
        current_y = stop_y;
        
        S.car_pos = axes('units','pix',...
                 'position',[current_x current_y current_size current_size],...
                 'ycolor',[0 1 1],...
                 'xcolor',[1 1 1],...
                 'color',[1 1 1],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','off');

        our_car_handle = imshow(our_car_image);
        set(our_car_handle, 'AlphaData', alpha_our);
        
        S.steering_box = axes('units','pix',...
                 'position',[center-steering_rect_width/2 
                            steering_rect_y_pos 
                            steering_rect_width 
                            steering_rect_height],...
                 'color',[1 1 240/255],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','on');
        
        S.left_boundary = axes('units','pix',...
                 'position',[center-(steering_rect_width/2)+(1-decision_boundary)*steering_rect_width/2 
                            steering_rect_y_pos 
                            2 
                            steering_rect_height],...
                 'color',[0 0 0],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','on');  
        S.right_boundary = axes('units','pix',...
                 'position',[center + decision_boundary*steering_rect_width/2
                            steering_rect_y_pos 
                            2 
                            steering_rect_height],...
                 'color',[0 0 0],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','on');
        x_1 = [center + C.value * steering_rect_width/2, center];
        
        S.steering_value = axes('units','pix',...
                 'position',[min(x_1)
                            steering_rect_y_pos
                            max(x_1) - min(x_1)
                            steering_rect_height],...
                 'color',[1 235/255 0],...
                 'xtick',[],'ytick',[],...
                 'xlim',[-.1 7.1],...
                 'ylim',[-.1 7.1],...
                 'visible','on');
        
        if mod(i,5) ==0
            C = C.updateValue();
            C.value
        end
            
        drawnow()
    end
    toc
end
close all

function [new_x] = mirror(x, current_size)
    new_x = center - ((x + current_size)-center);
end

function [] = fig_kpfcn(varargin)
% Figure (and pushbutton) keypressfcn
    switch varargin{2}.Key
        case 'rightarrow'
            C = C.putClass(1);
            if C.value > decision_boundary
               our_car_pos=1; 
            end
        case 'leftarrow'
            C = C.putClass(-1);
            if C.value < -decision_boundary
                our_car_pos = 0;
            end
        case 'q'
            running = false;
        otherwise
    end
    set(S.fig, 'Visible', 'on');
    drawnow;
end

end